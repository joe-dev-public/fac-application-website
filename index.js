'use strict';

/*

    Todo:
    =====

        - Code cleanup! DRY, function and variable names, etc.

        - Maybe add a checkbox to "load/unload code that 'was written by me', but was derived from example code written by someone else", with a note about how it affects functionality?

        - When a menu link is clicked in narrow view, close the menu after clicking?
            - I think we could do this by using JS to see if the CSS @media query has kicked in  (e.g. check if main nav menu button is visible?), then adding event listeners to the nav links.

        - Step seq:
            - Should we allow different numbers of steps per track? (But that all play back at an even rate of one step length = total time/number of steps? Polyrhythm fun.)
            - Careful with scrolling when changing number of tracks.
            - Implement multiple inputs for changing pattern length, e.g. one that is a slider with 4, 8, 12, 16, 32 marked off on a scale.
            - Click and drag across steps to activate many (with pref for always-toggle, always-activate, etc.)
            - If you show a number inside a step cell, make sure it can't be selected. Assuming 4/4, make all numbers dim except 1st, 5th, etc.
                - You could also show numbers outside the grid.
            - (I've accidentally made a pixel art grid with limited zooming at this stage, too :)
            - Tried making steps checkboxes so that they'd maintain checked state when page refreshed, but ofc they're all generated by JS so *won't* maintain state.
                - (Would need to handle that with some other kind of intentional storage method, I guess?)
            - Maybe write a constructor or whatever to generate new oscillators on the fly for each track?
            - Hijack right click on step to erase, or do a different note velocity, etc?
                - suppress right-click context menu *ONLY* if the mousedown originates in a step. (but regardless of where the mouse up event occurs)

        - Basic validation on the objects stuff inputs.

        Low priority:
        -------------
            - Tweak stringToObject, shoppingList string wrangling to handle ~less well-formed~ user input?
            - There may be unnecessary use of ".children" in prompts; remember you can use ELEMENT.getElementsByBlah, not just DOCUMENT.getElementsByBlah!
                - Also querySelectorAll, and maybe other things :)

            - Step seq accessibility: consider keyboard use?

            - Split this script into 3 different scripts, perhaps? "general stuff", "week 08", and "week 09"?



    Notes:
    ======

        - Why does HTMLElement.style.blah and dot notation like this in general work, and why am I struggling to find documentation for it?
            - Is it just that you're literally accessing the object, using dot notation? (Would bracket notation work? One test below suggests: yes!)
            - And that you have access to whatever properties it has, in the DOM/CSSOM/whatever, regardless of what you can find documented?
            - (Or, these properties will be documented somewhere, but not in the most "obvious" place?)
        - Sigh. This just makes debugging a bit less fun, y'know? https://bugzilla.mozilla.org/show_bug.cgi?id=1615206

        - It's not intuitive at first, but if you want to call a function with parameters when adding an event listener, this is one way to do it:
            element.addEventListener('mouseenter', function(e) {
                myFunction(e, param1, param2, etc);
            });
          An important downside being that you can't easily removeEventListener? (I mean, there's probably a way..)

        - For the contextmenu event, event.target seems to tell us where the mouseup occurs.
            Is there any way to find out where the mouse *down* occured? (I'm guessing not.)

        - For some reason, event.buttons will sometimes be 0 regardless of the button(s) pressed.
            - If that happens, try event.button - hopefully it'll give the right values.
            - There's big blue notes here: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
            - and here: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
            - which attempt to explain why, but I can't quite unpack it right now!

*/


// Wee helper function to "stop things doing stuff".
function doNothing(event) { event.preventDefault(); }


function makeMainNavCollapsible() {

    const mainNavMenuElement = document.getElementById('main-nav-menu');
    const mainNavMenuButtonElement = document.getElementById('main-nav-menu-button');

    // Perhaps OTT for this little script ;¬)
    const mainNavMenuElementHideClass = 'hide';
    const mainNavMenuButtonElementShowClass = 'show';

    // Make some markup and style changes that are only relevant if JS is active.
    mainNavMenuButtonElement.innerHTML += `<span id="main-nav-menu-button-arrow">&darr;</span>`;

    const mainNavMenuButtonArrowElement = document.getElementById('main-nav-menu-button-arrow');

    // Apply classes that will only have an effect if the relevant @media query is active
    mainNavMenuElement.classList.add(mainNavMenuElementHideClass);
    mainNavMenuButtonElement.classList.add(mainNavMenuButtonElementShowClass);

    function toggleMainNavMenuVisible(event) {

        // I think el.style.blah gives you the inline style, and at load we're not using an inline style, we're using one from style.css.
        // So we need a way to test the visibility of an element without checking its inline style (which may well be blank).

        let classes = mainNavMenuElement.classList;

        let hidden = false;

        // If the main nav menu has the "hide" class (which is the mechanism we use to hide it), then set the flag to true and leave the loop.
        for (let i = 0; i < classes.length; i++){
            if (classes[i] === mainNavMenuElementHideClass){
                hidden = true;
                break;
            }
        }

        // If the hidden flag is true, remove the hide class from the main nav menu. If it's false, add the class. Also change the button arrow ;)
        if (hidden === true){
            mainNavMenuElement.classList.remove(mainNavMenuElementHideClass);
            mainNavMenuButtonArrowElement.innerHTML = "&uarr;";
        } else if (hidden === false){
            mainNavMenuElement.classList.add(mainNavMenuElementHideClass);
            mainNavMenuButtonArrowElement.innerHTML = "&darr;";
        }

        doNothing(event);

    }

    mainNavMenuButtonElement.addEventListener('click', toggleMainNavMenuVisible);

}


/*
    -------------------------------------------------------
    Object stuff
    -------------------------------------------------------
*/

function capitaliseKeys(obj) {

    let newObj = {};

    for (const [key, value] of Object.entries(obj)) {

        /*
        Object.defineProperty(newObj, key.toUpperCase(), {
            enumerable: true,
            value: val
        });
        */

        // This does roughly the same thing; possibly exactly the same thing!
        newObj[key.toUpperCase()] = value;

    }

    return newObj;

} // end of function capitaliseKeys


function stringToObject(str) {

    let newObj = {};

    // A basic approach is to assume that commas *only* appear when delimiting pairs, and colons *only appear when separating a key from a value.
    // Of course, this is extremely error-prone :)
    let pairs = str.split(',');

    pairs.forEach( element => {
        let [key, value] = element.split(':');
        newObj[key] = value;
    });

    return newObj;

} // end of function stringToObject


function shoppingList(str) {

    let newObj = {};

    let pairs = str.split(', ');

    pairs.forEach( element => {
        let [value, key] = element.split(' '); // Extremely rudimentary, will break easily.
        newObj[key] = value; // You could do Number(value), if you really want it to be a number.
    });

    return newObj;

} // end of function shoppingList


function mapObject(obj, fn) {

    let newObj = {};

    for (const [key, value] of Object.entries(obj)) {
        newObj[key] = fn(value);
    }

    return newObj;

} // end of function mapObject


// Another little helper function :)
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!
// Use window.Function() to do something similar to eval() but MUCH safer/better (apparently). Not sure how safe this is really, but look into that later.
function definitelyNotEval(string){
    return Function('"use strict"; return ' + string + ';')();
}


function handleDemoInput(event) {

    const functionToCall = event.target.value;

    const outputElement = event.target.parentElement.parentElement.getElementsByClassName('demo-output')[0];

    // todo: handle multiple lines, validation, etc.

    let input = event.target.parentElement.getElementsByTagName('textarea')[0].value;

    // It's a string.
    //console.log(typeof input);

    // Is this a reliable way to get each line of a <textarea>?
    let lines = input.split(/\n/);

    let html = '';

    lines.forEach( (element, index) => {

        if (functionToCall === 'capitaliseKeys'){

            /*
                Treat the string "literally" as an object, or an object + function, because that's what these functions expect as per FAC's spec. :¬)

                We want to interpret the user-entered string "literally", i.e. we want to pretend it's JS code.
                (Side-note: I'm pretty sure this isn't what "literals" are, I just can't think of a better word to describe this.)

                Once upon a time I think this might've been done with "eval", but that's a huge security risk (and also performance hit, it turns out!).
                So we use the window.Function() approach, implemented above.

                This allows us to use literal (aka initializer) notation to initialise the Object from the user's text input.
                (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)

                (Messing around with JSON.stringify and JSON.parse shouldn't be necessary.)

                Todo: is there a way to catch any errors here and report them in the output, not just console?
            */

            element = definitelyNotEval(element); // Don't like doing this >:¬/

        }

        let returnedObject = {};

        if (functionToCall === 'mapObject'){

            // todo: can we trim whitespace first? (might need to do that for all of these functions)

            // split the user-entered string at the "}, " between the object and the function.
            // "throwaway variable" (in Lua I've used _, which might also be used in Python)
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
            // (via https://stackoverflow.com/questions/34628763/what-is-the-equivalent-of-pythons-in-javascript)
            // note: because match groups are 1-indexed, you don't need the 0th item here:
            let [, obj, fn] = element.match(/^(.*}), (.*)$/);

            obj = definitelyNotEval(obj);
            fn = definitelyNotEval(fn);

            returnedObject = window[functionToCall](obj, fn);

        } else {
            // Call a function where its name is a variable string by using bracket notation on the Window interface
            returnedObject = window[functionToCall](element);
        }

        //console.log(returnedObject);

        html += `Return type: ${typeof returnedObject}<br><br>`;

        for (const [key, value] of Object.entries(returnedObject)) {
            html += `${key}: ${value}<br>`;
        }

        // Don't add two line breaks if we're at the last line of input. (Could be neater with CSS, but I learned about forEach index this way!)
        if (index < lines.length - 1){ html += '<br><br>'; }

    });

    outputElement.innerHTML = html;

}


function initWeek08() {

    const demoInputElements = document.getElementsByClassName('demo-input');

    for (let i = 0; i < demoInputElements.length; i++){

        demoInputElements[i].addEventListener('submit', doNothing);

        // Not best practice, as this could break if you add another button.
        const submitButtonElement = demoInputElements[i].getElementsByTagName('button')[0];

        submitButtonElement.addEventListener('click', handleDemoInput);

    }

}

/*
    -------------------------------------------------------
    End of Object stuff
    -------------------------------------------------------
*/



/*
    -------------------------------------------------------
    Start of step sequencer stuff
    -------------------------------------------------------
*/

// todo: fix scoping etc. to be best-practice :)
let numberOfStepsElement;
let numberOfTracksElement;

let stepGridElement;

// Declare objects to store settings elements and values
let settingsElements = {};
let settingsValues = {};

// Hard-coding these for now
const maxNumberOfTracks = 8;
const minNumberOfTracks = 1;
const maxNumberOfSteps = 32;
const minNumberOfSteps = 1;

let isDragging = false;

const regexActiveStep = new RegExp(/step-active/);
const regexHiddenStep = new RegExp(/hidden/);

function activateStep(target) {
    target.classList.add('step-active');
}

function deactivateStep(target) {
    target.classList.remove('step-active');
}

function toggleStep(target) {
    if (regexActiveStep.test(target.classList) === true){
        deactivateStep(target);
    } else {
        activateStep(target);
    }
}

function dragOverSteps(event) {

    // todo: add ui behaviour options so that dragging will always-on or toggle. also consider what mouse button is being used.

    // todo: there might be a way to reduce duplicated code here, for where the actions to take are identical. Maybe later.

    if (event.buttons === 1){

        // Primary-drag

        // todo: we potentially have a slightly tricky thing to handle here, which is that I might have created options which could sorta conflict with one another!
        // e.g. the "single click" action could conflict with the "click-drag" action
        // theoretically it's OK, but it relies on possibly modifying the state of the clicked step during the dragging process, which could look weird.
        // Keep an eye out for this!

        if (event.target.stepClickedActive === true){

            // The step that the click-drag started from *was* active

            // Check settings to see what action to take.
            switch (settingsValues['primary-button-active-drag']) {

                case '1':
                    // todo: This is *kinda* the same as "do nothing". Remove this option? Wait and see.
                    // OK yeah, this is weird! it works nicely, but just feels very odd.
                    // Technically you should combine the right click option with the right drag option to get the interaction you want
                    // Great learning experience!
                    deactivateStep(event.target.clickedStepElement);
                    break;
                case '2':
                    deactivateStep(event.target.clickedStepElement);
                    deactivateStep(event.target);
                    break;
                case '3':
                    deactivateStep(event.target.clickedStepElement);
                    activateStep(event.target);
                    break;
                case '4':
                    deactivateStep(event.target.clickedStepElement);
                    toggleStep(event.target);
                case '5':
                    // Do nothing
                    break;

            }

        } else {

            // The step that the click-drag started from *wasn't* active

            switch (settingsValues['primary-button-inactive-drag']) {

                case '1':
                    activateStep(event.target.clickedStepElement);
                    break;
                case '2':
                    activateStep(event.target.clickedStepElement);
                    activateStep(event.target);
                    break;
                case '3':
                    activateStep(event.target.clickedStepElement);
                    deactivateStep(event.target);
                    break;
                case '4':
                    activateStep(event.target.clickedStepElement);
                    toggleStep(event.target);
                case '5':
                    // Do nothing
                    break;

            }


        }

    } else if (event.buttons === 2){

        // right-drag

        if (event.target.stepClickedActive === true){

            // the step that the right-click-drag started from was active

            switch (settingsValues['secondary-button-active-drag']) {

                case '1':
                    deactivateStep(event.target.clickedStepElement);
                    break;
                case '2':
                    deactivateStep(event.target.clickedStepElement);
                    deactivateStep(event.target);
                    break;
                case '3':
                    deactivateStep(event.target.clickedStepElement);
                    activateStep(event.target);
                    break;
                case '4':
                    deactivateStep(event.target.clickedStepElement);
                    toggleStep(event.target);
                case '5':
                    // Do nothing
                    break;

            }

        } else {

            switch (settingsValues['secondary-button-inactive-drag']) {

                case '1':
                    activateStep(event.target.clickedStepElement);
                    break;
                case '2':
                    activateStep(event.target.clickedStepElement);
                    activateStep(event.target);
                    break;
                case '3':
                    activateStep(event.target.clickedStepElement);
                    deactivateStep(event.target);
                    break;
                case '4':
                    activateStep(event.target.clickedStepElement);
                    toggleStep(event.target);
                case '5':
                    // Do nothing
                    break;

            }

        }

    }


}



function removeDragStepToggleThing(event) {

    let allStepElements = document.getElementsByClassName('step');

    for (let i = 0; i < allStepElements.length; i++) {

        allStepElements[i].removeEventListener('mouseenter', dragOverSteps);

    }

    // This seems to work, but is it good practice?
    document.removeEventListener('mouseup', removeDragStepToggleThing);

}



function mousedownOnStep(event) {

    let clickedStepElement = event.target;

    let allStepElementsOnSameTrack = event.target.parentElement.children;

    // Set the active flag to false by default (it's arbitrary whether to default to true or false and check for the opposite).
    let active = false;

    // First, check to see if the clicked step was active, and if so, set the active flag to true.
    // This is checked by the mouseenter event listener on all the steps that weren't clicked, and can be set regardless of what action to take.
    if (regexActiveStep.test(clickedStepElement.classList) === true) {
        active = true;
    }

    // out of date notes to sort:
    // todo: add an option for not changing state of clicked step until mouse up.
    // to me, it feels weird if you mousedown on one, it changes, but then the DRAG will always-on the others. still, that's what this tool is for, working out what feels weird :)
    //
    // how about: mousedown to on, mousedown+up to off? that should def be an option.
    // I think this is logically possible, if you test for the current stage? it's like a latching physical switch?

    // ? todo: rejig logic here so you DRY
    if (event.buttons === 1) {

        // Primary button (usually left) mousedown 

        // Check settings to see what action to take.
        switch (settingsValues['primary-button-single-click']) {

            case '1':
                toggleStep(clickedStepElement);
                break;
            case '2':
                activateStep(clickedStepElement);
                break;
            case '3':
                deactivateStep(clickedStepElement);
                break;
            case '4':
                break;

        }

    } else if (event.buttons === 2) {

        // Secondary button mousedown (usually right)

        // As above: check settings to determine what action to take.
        switch (settingsValues['secondary-button-single-click']) {

            case '1':
                toggleStep(clickedStepElement);
                break;
            case '2':
                activateStep(clickedStepElement);
                break;
            case '3':
                deactivateStep(clickedStepElement);
                break;
            case '4':
                break;

        }

    }

    // Add listener for mouseenter on other visible steps on same track only, and act on them too
    // todo: make this "same track only" restriction optional. Some people might want to drag across multiple tracks...

    for (let i = 0; i < allStepElementsOnSameTrack.length; i++) {

        if (regexHiddenStep.test(allStepElementsOnSameTrack[i].classList) === false && allStepElementsOnSameTrack[i] != clickedStepElement){

            allStepElementsOnSameTrack[i].addEventListener('mouseenter', dragOverSteps);
            // vintage SE stuff. https://stackoverflow.com/questions/256754/how-to-pass-arguments-to-addeventlistener-listener-function
            // is using a parameter like this best practice? any downsides?
            allStepElementsOnSameTrack[i].stepClickedActive = active;

            // todo: the main downside to this approach is that we act on the originally-clicked step for EVERY mouseenter that follows.
            // Really we want to do this once at mousedown, and stop. Possible?
            allStepElementsOnSameTrack[i].clickedStepElement = clickedStepElement;

        }

    }

    /*  mousedown has already occured.
        We want to ensure that the context menu won't appear on mouseup.
        So, set an appropriate flag:
    */
    isDragging = true;

    /*  Finally, add an event listener for mouseup on the document. We do this rather than just listen for mouseup on a step element because
        the user could release the mouse when not over a step element (they could release it anywhere, and covering "document" covers every case?).

        I don't know if using "document." is best practice, but it works. (Would "window." be better? Does the lack of specificity of either cause a problem?)
        Note: there might be a simpler approach to this, similar to the isDragging approach above.
    */
    document.addEventListener('mouseup', removeDragStepToggleThing);

}



function initTracks() {

    // getAttribute isn't live but that's fine cos we want to use what's coded in the markup as our default
    const defaultNumberOfVisibleTracks = numberOfTracksElement.getAttribute('value');

    let html = '';

    for (let i = 1; i <= maxNumberOfTracks; i++) {

        html += `<div class="track`;

        if (i > defaultNumberOfVisibleTracks) {
            html += ` hidden`; // is this necessary given the updatevisible thing is called below?
        }


        html += `
">
    <form class="track-controls">
        Track ${i}
        <!--
        <label>
            Pitch
            <input type="range" class="pitch-slider" min="440" max="4400" value="880" step="100">
        </label>
        <label>
            Sustain
            <input type="range" class="sustain-slider" min="0.01" max="0.5" value="0.05" step="0.01">
        </label>
        -->
    </form>
    <div class="track-step-area"></div>
</div>
`;


    }

    stepGridElement.innerHTML = html;

}


function initSteps() {

    const defaultNumberOfVisibleSteps = numberOfStepsElement.getAttribute('value');

    let html = '';

    for (let i = 1; i <= maxNumberOfSteps; i++) {
        if (i <= defaultNumberOfVisibleSteps) {
            html += `<div class="step">${i}</div>`;
        } else {
            html += `<div class="step hidden">${i}</div>`;
        }
    }

    // todo: DRY
    let trackStepAreaElements = document.getElementsByClassName('track-step-area');

    for (let i = 0; i < trackStepAreaElements.length; i++) {
        trackStepAreaElements[i].innerHTML = html;
    }

    let allStepElements = document.getElementsByClassName('step');

    for (let i = 0; i < allStepElements.length; i++) {

        // todo: mousedown feels a lot more responsive than click, but make this configurable?
        allStepElements[i].addEventListener('mousedown', mousedownOnStep);

        /*  We are implementing a kind of drag interaction here.
            (Might there might be a built in way to do it using https://developer.mozilla.org/en-US/docs/Web/API/DragEvent ? I haven't checked yet!)

            In addition to the event listener for mousedown, we'll need one for mouseup, so that the dragging interaction can stop!
            However, we can't add the mouseup listen here, because the user might release the mouse *outside* of a step element.
            So we need a more general method that listens for the mouseup everywhere. That's currently implemented in the mousedown listener function.
        */

        /*
            We don't want the context menu to appear if a user secondary-clicks a step, or if they secondary-drag from a step (and mouseup anywhere).
            We *could* stop the context menu appearing when any step element is secondary-clicked by putting this here:

            allStepElements[i].addEventListener('contextmenu', doNothing);

            But that wouldn't stop the context menu opening if the user released the mouse (i.e. stopped dragging) *outside* of a step element.
            So, we have a more general method in place to handle that case.
            And as it also handles the mouseup-on-a-step-element case, we don't bother adding an event listener for contextmenu here.
        */

    }

}


function updateNumberOfVisibleTracks(event) {

    let targetNumberOfVisibleTracks = Number(event.target.value);

    if (targetNumberOfVisibleTracks > maxNumberOfTracks) {
        return false;
    } else if (targetNumberOfVisibleTracks < minNumberOfTracks) {
        return false;
    }

    // todo: DRY
    let trackElements = document.getElementsByClassName('track');

    for (let i = 0; i < trackElements.length; i++) {
        if (i < targetNumberOfVisibleTracks){
            trackElements[i].classList.remove('hidden');
        } else {
            trackElements[i].classList.add('hidden');
        }
    }

}


let targetNumberOfVisibleSteps;

function updateNumberOfVisibleSteps(event) {

    // Just show or hide, that way user-entered sequences aren't lost if the pattern length is changed.
    // Hopefully this won't affect performance in any noticeable way!

    targetNumberOfVisibleSteps = Number(event.target.value);

    if (targetNumberOfVisibleSteps > maxNumberOfSteps) {
        return false;
    } else if (targetNumberOfVisibleSteps < minNumberOfSteps) {
        return false;
    }

    // todo: DRY
    let trackElements = document.getElementsByClassName('track');

    for (let i = 0; i < trackElements.length; i++) {

        let stepElements = trackElements[i].getElementsByClassName('step');

        for (let j = 0; j < stepElements.length; j++) {
            if (j < targetNumberOfVisibleSteps){
                stepElements[j].classList.remove('hidden');
            } else {
                stepElements[j].classList.add('hidden');
            }
        }

    }

}



/*
    -------------------------------------------------------
    Start of step seq playback stuff
    -------------------------------------------------------
*/

    // Lots of below pieced together from:



    // create web audio api context

const audioContext = new (window.AudioContext || window.webkitAudioContext)();

let volume = 0.1; // todo: Read default from html
let pitch = 440;
let sustain = 0.05;

function makeNoise(time, pitch, sustain) {

    // https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode

    let gainNode = audioContext.createGain();

    gainNode.gain.value = volume;

    // create Oscillator node
    const osc = audioContext.createOscillator();

    osc.type = 'sine';
    osc.frequency.value = pitch;
    osc.connect(gainNode).connect(audioContext.destination);
    osc.start(time);
    osc.stop(time + sustain); // quick hacky way to do sustain, should use an envelope?

}


let timeSigNumerator = 4; // todo: read default from html.
let timeSigDenominator = 4;

let tempo = 120.0; // todo: change this to the default value from the html.

let stepLength = 0.0625; // 1/16. todo: change this to the default value from the html.

const lookahead = 25.0; // How frequently to call scheduling function (in milliseconds)
const scheduleAheadTime = 0.1; // How far ahead to schedule audio (sec)

let currentNote = 0;
let nextNoteTime = 0.0; // when the next note is due.

function nextNote() {

    /*

        Ah, from https://en.wikipedia.org/wiki/Tempo:
            "The note value of a beat will typically be that indicated by the denominator of the time signature.
            For instance, in 4/4 the beat will be a crotchet, or quarter note."
        A stark reminder that I've never internalised what time signatures actually mean. ;¬)
        So the assumption that in 4/4 one beat = one whole note (semibreve) is wrong, which explains why
            const secondsPerStep = stepLength * (60 / tempo);
        plays back "four times faster" that expected!
        The most flexible thing to do here is allow the user to select a time signature, and calculate seconds per step based on that.
        Note: I don't yet understand how the time sig *numerator* might affect this, so my implementation will probably be broken! :¬)

    */
    const secondsPerStep = (stepLength * timeSigDenominator) * (60 / tempo);

    nextNoteTime += secondsPerStep; // Add step length to last step time

    // Advance the step number, wrap to zero
    currentNote++;

    if (currentNote === targetNumberOfVisibleSteps) {
            currentNote = 0;
    }
}

const notesInQueue = [];

let timerID;

let trackElements = document.getElementsByClassName('track');

function scheduleNote(stepNumber, time) {

    // push the note on the queue, even if we're not playing.
    notesInQueue.push({ note: stepNumber, time: time });


    // todo: don't just hard-code to first track
    //let classlist = trackElements[0].querySelectorAll('.step')[stepNumber].classList;

    // remember we only want to play back visible tracks and steps!
    // maybe update an array/whatever with the list of those that are visible when visibility is updated? (helps performance hopefully)
    let re1 = new RegExp(/hidden/);
    let re2 = new RegExp(/step-active/);

    for (let i = 0; i < trackElements.length; i++) {

        if (re1.test(trackElements[i].classList) === false) {

            // if you're wondering why we don't have to test for the step visibility here, it's because targetNumberOfVisibleSteps in nextNote() handles that already. keep track!

            // todo: this works. simultaneous steps seem to sum in velocity.
            // I'm not sure if the behaviour is consistent cos we're potentially misusing our "one osc".
            // e.g. if their total velocity sum is 1, then I think it won't get louder. (fine for our demo, but would be unexpected in the "real world".)
            // so maybe we'll change to a method where each track has its own osc?
            if (re2.test(trackElements[i].querySelectorAll('.step')[stepNumber].classList) === true){
                makeNoise(time, pitch, sustain);
            }

        }

    }


/*
    if (re.test(classlist) === true) {
        makeNoise(time, pitch, sustain);
    }
*/

}


function scheduler() {
    // while there are notes that will need to play before the next interval, schedule them and advance the pointer.
    while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
        scheduleNote(currentNote, nextNoteTime);
        nextNote();
    }
    timerID = window.setTimeout(scheduler, lookahead);
}


let lastNoteDrawn = 3;

let trackStepAreas = document.getElementsByClassName('track-step-area');

function draw() {

    // todo:
    // when you stop, the highlight will stop in the current position, but when you start playing, it's always from the beginning.
    // easiest fix is to call it play/stop(reset), and just remove all highlights upon stopping.

    let drawNote = lastNoteDrawn;
    let currentTime = audioContext.currentTime;

    while (notesInQueue.length && notesInQueue[0].time < currentTime) {
        drawNote = notesInQueue[0].note;
        notesInQueue.splice(0,1);   // remove note from queue
    }

    let re = new RegExp(/hidden/);

    // We only need to draw if the note has moved.
    if (lastNoteDrawn != drawNote) {
        for (let i = 0; i < trackStepAreas.length; i++) {

            if (re.test(trackStepAreas[i].parentElement.classList) === false) {

                // Only do something if the tracks are visible. (What's the performance implication? Better to change classes on hidden elements or do the test?)
                // Todo: this has the side-effect of leaving the .highlight class on some steps, so that they're incorrectly highlighted when the track is re-shown.
                // One workaround would be to have the function that updates track visibility just reset this class on steps. Maybe sort that out later.
                trackStepAreas[i].children[lastNoteDrawn].classList.remove('highlight');
                trackStepAreas[i].children[drawNote].classList.add('highlight');

            }


        }

        lastNoteDrawn = drawNote;
    }
    // set up to draw again
    requestAnimationFrame(draw);
}

/*
    -------------------------------------------------------
    End of step seq playback stuff
    -------------------------------------------------------
*/


function conditionallyDisableContextMenu(event) {

    // Note: this won't disable the context menu if the user releases a secondary-drag in certain parts of the browser, e.g. the window title bar! (But I think that's fine for now. :)

    if (isDragging === true){

        event.preventDefault();

        isDragging = false;

    }

}


function updateStepSeqSettings(event) {

    // We're not allowing multiple selections, so [0] should be OK. Is there another reason it might be bad to use?
    settingsValues[event.target.id] = event.target.selectedOptions[0].value;

}


function initStepSeqSettings() {

    // Keep settings element names and IDs in an array for ease of writing and maintenance.
    // Todo: the end game here is an object that has all the settings and their possible states stored in one place, for populating the HTML. Much easier to maintain!
    let settings = [
        'primary-button-single-click',
        'primary-button-active-drag',
        'primary-button-inactive-drag',
        'secondary-button-single-click',
        'secondary-button-active-drag',
        'secondary-button-inactive-drag'
    ];


    // Keep the elements themselves in another object.
    // Currently set up to handle <select> settings only!
    // Todo: change this so it can handle other kinds of settings inputs?
    settings.forEach( element => {

        settingsElements[element] = document.getElementById(element);

        settingsElements[element].addEventListener('input', updateStepSeqSettings);

    });


    for (const [key, val] of Object.entries(settingsElements)) {

        for (let i = 0; i < val.selectedOptions.length; i++){

            settingsValues[key] = val.selectedOptions[i].value;

        }

    }


}


function initStepSeq() {

    initStepSeqSettings();

    numberOfStepsElement = document.getElementById('number-of-steps');
    numberOfTracksElement = document.getElementById('number-of-tracks');

    stepGridElement = document.getElementById('stepgrid');

    initTracks();
    initSteps();

    numberOfStepsElement.addEventListener('input', updateNumberOfVisibleSteps);
    numberOfTracksElement.addEventListener('input', updateNumberOfVisibleTracks);

    // Is this really the best way to do this? (It seems to work!)
    // Trigger built-in event:
    // https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events
    // https://developer.mozilla.org/en-US/docs/Web/API/InputEvent
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
    const inputEvent = new InputEvent('input');
    numberOfStepsElement.dispatchEvent(inputEvent);
    numberOfTracksElement.dispatchEvent(inputEvent);

    document.addEventListener('contextmenu', conditionallyDisableContextMenu);

}

/*
    -------------------------------------------------------
    End of step sequencer stuff
    -------------------------------------------------------
*/



function windowLoaded() {

    makeMainNavCollapsible();

    initWeek08();

    initStepSeq();

} // end of function windowLoaded